---
openapi: get /get-response
---

⚠️ This is a streaming endpoint using [Server-Sent Events (SSE)](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events).

Opens a live SSE stream to receive real-time response messages from the conversational agent after sending a message.

Use the temporary token received from `/generate_secret` or `/get_inference` as applicable to authenticate the stream.

The stream sends `event.data` messages that include control signals or agent-generated content.

---

## 1. Connection Closing

- `close_connection`: Indicates the normal end of the stream. The client **must close** the `EventSource` connection.

---

## 2. Stream Continuation

- `call_again`: Indicates a tool/function call occurred. You've to set your message loading state to true and new message chunks will be sent in the stream.

---

## 3. Error / Restriction Signals

These indicate problems or user restrictions. In all cases, the client must close the connection.

- `no_message_found`: The agent was unable to generate a response as no user message corresponding to request found.
- `close_connection_incomplete_content`: AI model exceeded its response context window.
- `close_connection_incomplete_tool_calls`: Context overflow occurred while generating tool call arguments.
- `close_connection_incomplete_request`: Context overflow occurred while generating response.
- `__ERROR__: ....`: An error occurred while processing the request.
- `[FROZEN]` / `[BLACKLISTED]`: User access restrictions triggered.

---

## 4. AI Agent Response Content

- JSON payloads: Contain AI Agent Response message content. When streaming is **ON you will receive message chunks**, and when streaming is **OFF you will get the full response in a single JSON payload**.

**When Streaming is ON:**

```json
data: {"content": "How"}

data: {"content": " can"}

data: {"content": " I"}

data: {"content": " assist"}

data: {"content": " you"}

data: {"content": " today"}

data: {"content": "?"}

data: close_connection
```

When Streaming is OFF:

```json
data: {"content": "How can I assist you today?"}

data: close_connection

```

Example Implementation

```js
const displayNewMessageHandler = (message, token) => {
  setConversationMessages((prev) => {
    // set your messages state here
    const lastMessage = prev[prev.length - 1];
    if (lastMessage.role === 'assistant' && lastMessage.streamToken === token) {
      // last message is assistant and has the same token -> chunks of message is to be appended
      const updatedData = [...prev];
      updatedData[prev.length - 1] = {
        ...lastMessage,
        content: lastMessage.content + message,
      };
      return updatedData;
    } else {
      // new assistant message
      const newMessage = { role: 'assistant', content: message, time: new Date().toLocaleString('en-IN'), streamToken: token };
      return [...prev, newMessage];
    }
  });

  // you have to save the conversationMessages to local storage or any other persistent storage, chatzy AI doesn't expose any API to fetch conversation history
};

const callSourceHandler = (token) => {
  // token is the temp token generated by `/generate_secret?conversation_id=...`
  const source = new EventSource(`https://backend-1.chatzy.ai/get-response?token=${token}`);

  source.onmessage = (event) => {
    if (event.data === 'call_again') {
      // Tool call executed
      // set your message loading state here
    } else if (event.data === 'close_connection') {
      // End of stream
      source.close();
    } else if (event.data === 'no_message_found') {
      source.close();
    } else if (event.data === 'close_connection_incomplete_content') {
      source.close();
    } else if (event.data === 'close_connection_incomplete_tool_calls') {
      source.close();
    } else if (event.data === 'close_connection_incomplete_request') {
      source.close();
    } else if (['[FROZEN]', '[BLACKLISTED]'].includes(event.data)) {
      console.warn('Your access is temporarily restricted.'); // show error message to user
      source.close();
    } else if (event.data.includes('__ERROR__')) {
      console.error('Error occurred while processing the request:', event.data);
      source.close();
    } else {
      let dataObject;
      try {
        dataObject = JSON.parse(event.data);
      } catch {
        // console.error('Error parsing JSON data:', event.data);
      }

      if (dataObject?.content) {
        displayNewMessageHandler(dataObject.content, token);
      }
    }
  };

  source.onerror = function (error) {
    source.close();
    console.error(`EventSource failed:`, error);
  };
};
```
